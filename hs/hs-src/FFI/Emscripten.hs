{-# LANGUAGE JavaScriptFFI #-}
module FFI.Emscripten
  ( Mod
  , mod
  , modFun
  , Fun
  , fun
  , Name
  , name
  , Ret(..)
  , Arg(..)
  , Zero(..)
  , wrappedFun
  , setGlobal
  , wrapGlobals
  ) where

--------------------------------------------------------------------------------

-- | The type of the return type from a CCALL, insofar as GHCJS is concerned.
data Ret
  = RetVoid
  -- ^ C's @void@. In Haskell, this is represented as `()`.
  | RetVal
  -- ^ Single 'JSVal'. That is, something like 'Int32' or 'Bool'.
  | RetI64
  -- ^ Size-2 GHCJS integral value. That is, something like 'Word64'
  -- or 'Foreign.C.Tytes.CLLong'.
  | RetStr
  -- ^ A @NUL@-terminated C string.

--------------------------------------------------------------------------------

-- | The type of an argument to a CCALL, insofar as GHCJS is concerned.
data Arg
  = ArgVal
  -- ^ Single 'JSVal'. That is, something like 'Int32' or 'Bool'.
  | ArgI64
  -- ^ Size-2 GHCJS integral value. That is, something like 'Word64'
  -- or 'Foreign.C.Tytes.CLLong'.
  | ArgBufR Zero
  -- ^ A buffer for __reading__ purposes on the Emscripten side.
  -- 'Foreign.C.Ptr.Ptr's are usually represented as 'GHCJS.Buffer.Buffer's.
  | ArgBufW Zero
  -- ^ A buffer for __writing__ purposes on the Emscripten side.
  -- 'Foreign.C.Ptr.Ptr's are usually represented as 'GHCJS.Buffer.Buffer's.
  | ArgBufRW Zero
  -- ^ A buffer for __reading and writing__ purposes on the Emscripten side.
  -- 'Foreign.C.Ptr.Ptr's are usually represented as 'GHCJS.Buffer.Buffer's.

--------------------------------------------------------------------------------

-- | Whether a buffer should be zeroed after use on the Emscripten side.
newtype Zero = Zero Bool

--------------------------------------------------------------------------------

-- | An Emscripten module. Construct with 'module'.
--
-- This is the JavaScript object produced by Emscripten, containing properties
-- like @_malloc@, @_free@, @HEAPU8@, @getTempRet0@, etc.
newtype Mod = Mod JSVal

-- | Obtain an Emscripten 'Mod'ule from a 'JSVal', if suitable.
mod :: JSVal -> Maybe Mod
mod = fmap Mod . pFromJSVal

--------------------------------------------------------------------------------

-- | An Emscripten-compiled function. Construct with 'fun'.
data Fun = Fun JSVal

-- | Obtain a 'Fun'ction from a 'JSVal', which must be one of the
-- @_foo@ functions (notice the leading underscore) generated by Emscripten.
--
-- Consider using the easier 'modFun'.
fun :: JSVal -> Maybe Fun
fun = fmap Fun . pFromJSVal

--------------------------------------------------------------------------------

-- | A CCALL function name.
newtype Name = Name JSString
  deriving newtype instance (Show, IsString)

-- | Obtain a Emscripten 'Fun'ction from an Emscripten 'Mod'ule, by 'Name'.
--
-- For example, if your Emscripten module @m@ exports a C function named “foo”
-- —available on JavaScript as @m._foo@—, then @'modFun' m \"foo\"@ will resolve
-- to @m._foo@.
modFun :: Mod -> Name -> Maybe Fun
modFun (Mod m) (Name n) = fun =<< pFromJSVal (js_unsafeGetProp m ("_" <> n))
{-# NOINLINE modFun #-}

--------------------------------------------------------------------------------

-- | JavaScript representation of a 'Ret'. Construct with 'jsRet'.
newtype JsRet = JsRet { unJsRet :: Int }

jsRet :: Ret -> JsRet
jsRet = JsRet . \case
  RetVoid -> js_Ret_VOID
  RetVal  -> js_Ret_VAL
  RetI64  -> js_Ret_I64
  RetStr  -> js_Ret_STR

--------------------------------------------------------------------------------

-- | JavaScript representation of an 'Arg'. Construct with 'jsArg'.
newtype JsArg = JsArg { unJsArg :: Int }

jsArg :: Arg -> JsArg
jsArg = JsArg . \case
  ArgVal            -> js_Arg_VAL
  ArgI64            -> js_Arg_I64
  ArgBufR  (Zero z) -> js_Arg_BUFZ z .|. js_Arg_BUFR
  ArgBufW  (Zero z) -> js_Arg_BUFZ z .|. js_Arg_BUFW
  ArgBufRW (Zero z) -> js_Arg_BUFZ z .|. js_Arg_BUFR .|. js_Arg_BUFW

--------------------------------------------------------------------------------

-- | An Emscripten 'Fun' converted to a JavaScript function that fits
-- GHCJS's FFI CCALL expectation. Construct with 'wrappedFun'.
newtype WrappedFun = WrappedFun JSVal

wrappedFun :: Mod -> Fun -> Ret -> [Arg] -> WrappedFun
wrappedFun (Mod m) (Fun f) ret args =
  let ret' = unJsArg (jsArg ret)
      args' = JSArray.fromList (fmap (pToJSVal . unJsArg . jsArg) args)
  in js_wrap m f ret' args'


--------------------------------------------------------------------------------

setGlobal :: Name -> WrappedFun -> IO ()
setGlobal (Name n) (WrappedFun f) = js_setGlobal ("h$" <> n) f

--------------------------------------------------------------------------------

-- | Given an Emscripen 'Mod'ule and the 'Name's and details of the
-- 'Fun'ctions to wrap
-- TODO DOCS
wrapGlobals :: Mod -> [(Name, Ret, [Arg])] -> IO (Either String ())
wrapGlobals m = traverse $ \(n, r, as) -> do
  case modFun m n of
    Nothing -> pure $ Left ("Missing module attribute: " <> show name)
    Just f  -> Right <$> setGlobal n (wrappedFun m f r as)

--------------------------------------------------------------------------------

foreign import javascript "h$ffi_emscripten.Ret.VOID" js_Ret_VOID :: Int
foreign import javascript "h$ffi_emscripten.Ret.VAL"  js_Ret_VAL  :: Int
foreign import javascript "h$ffi_emscripten.Ret.I64"  js_Ret_I64  :: Int
foreign import javascript "h$ffi_emscripten.Ret.STR"  js_Ret_STR  :: Int

foreign import javascript "h$ffi_emscripten.Arg.VAL"  js_Arg_VAL  :: Int
foreign import javascript "h$ffi_emscripten.Arg.I64"  js_Arg_I64  :: Int
foreign import javascript "h$ffi_emscripten.Arg.BUFR" js_Arg_BUFR :: Int
foreign import javascript "h$ffi_emscripten.Arg.BUFW" js_Arg_BUFW :: Int
foreign import javascript "h$ffi_emscripten.Arg.BUFZ" js_Arg_BUFZ :: Int

foreign import javascript "h$ffi_emscripten.wrap"
  js_wrap :: JSVal   -- ^ Mod
          -> JSVal   -- ^ Fun
          -> Int     -- ^ Ret
          -> JSArray -- ^ [Arg]
          -> JSVal   -- ^ WrappedFun

foreign import javascript "h$ffi_emscripten.setGlobal"
  js_setGlobal :: JSString -> JSVal -> IO ()

-- | The returned 'JSVal' may be @undefined@.
foreign import javascript "$1[$2]"
  js_unsafeGetProp :: JSVal -> JSString -> JSVal

